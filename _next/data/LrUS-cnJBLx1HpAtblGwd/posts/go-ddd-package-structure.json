{"pageProps":{"slug":"go-ddd-package-structure","postData":{"id":"go-ddd-package-structure","contentHtml":"<h1 id=\"overview\">Overview</h1>\n<p>本記事は Web アプリケーションを作る場合の Go のパッケージストラクチャについての考察である。</p>\n<p>リポジトリのアーキテクチャは拡張性や認識容易性、結合度・凝縮度などに影響する。ビジネスの変化に迅速に柔軟に対応するサービスを構築するためには、エンジニア自身もビジネスドメインを理解し DDD をベースとしたアプローチが良いという考えが最近より強くなってきた。\nDDD をプログラムで表現するのはレイヤードアーキテクチャ、特に <a href=\"https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/\">オニオンアーキテクチャ</a> が良いと思うが、<a href=\"https://www.shoeisha.co.jp/book/detail/9784798131610\">実践ドメイン駆動設計</a> や\n<a href=\"https://www.kadokawa.co.jp/product/301806000678/\">Clean Architecture</a> などの本を見たら分かる通り、レイヤード系のアーキテクチャは基本的に Java のような言語を想定して記述されている。</p>\n<p>Go はそういった言語とはパッケージの思想が異なるため、レイヤーの思想を安易に表現すると返って扱いづらい。Go は Goの特徴を考慮した形で実現するのが良いだろう。</p>\n<p>なお、ここで書かれている内容は私が関わる組織でも必ずしも実践されているわけではない。あくまで個人的な考察である。</p>\n<p>本記事を理解するために必要な知識</p>\n<ul>\n<li>Go の知識</li>\n<li>アーキテクチャの知識\n<ul>\n<li>DDD</li>\n<li>Clean Architecture</li>\n<li>Onion Architecture</li>\n</ul>\n</li>\n<li>参考となる本\n<ul>\n<li>Clean Architecture</li>\n<li>アジャイルソフトウェア開発の奥義</li>\n<li>Domain-Driven Design: Tackling Complexity in the Heart of Software</li>\n<li>実践ドメイン駆動設計</li>\n<li>Patterns of Enterprise Application Architecture (PoEAA)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"前提条件\">前提条件</h1>\n<p>DDD を前提とした場合、重要視したいのは <a href=\"https://ja.wikipedia.org/wiki/SOLID\">SOLID原則</a>、特に single-responsibility principle を重視したい。つまり、凝縮度を高めるためビジネスドメインにおける関心事を一定箇所(ドメインモデル)に閉じ込め、変更時にはその箇所を注目したら良く、同時に他のドメインへ影響を与えないようにしたい。</p>\n<p>一方で、ソフトウェア開発の原則で同様に言われる <a href=\"https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself\">DRY (Don't repeat yourself )原則</a>はある意味緩める必要がある。</p>\n<p>例えば、商品(item)といった場合に販売ドメインと配送ドメインでは関心事が異なる。販売ドメインでは商品の価格や状態が関心事だが、配送ドメインにおいては同じ「商品」と言ったときでも配送先や配送状況など関心事が異なる。</p>\n<p>引用: <a href=\"https://little-hands.hatenablog.com/entry/2017/11/28/bouded-context-concept\">https://little-hands.hatenablog.com/entry/2017/11/28/bouded-context-concept</a>\n<img src=\"./item-domain.png\" alt=\"Item Domain\"></p>\n<p>この時、DRY を意識して商品という概念(Entity)を使いまわそうとすると、売値・状態・配送先・配送状態など異なるドメインの関心事を全て詰め込み、状況次第で利用するフィールドを変えるというアプローチになる。<br>\n概念の異なるドメインでリソースを共有すると結合度が上がり、一方のドメインでの変更がもう一方のドメインへ意図せず影響する可能性が高まる。\n例えば商品販売の管理のため内部的な商品名の名付けルールを変えたら配送時にお客様への表示商品名のルールまで変わってしまうなどである。\nこうなると、プログラムの複雑性が高い影響で各ドメインの身動きが取りづらくなり、バグ発生率が高まり変更の実現のサイクルが遅くなってしまう。<br>\nそこで、多少繰り返し(のような見え方)になろうとも、ドメインごとに独自のリソースを設け、変更の影響範囲を狭め、注目するべき部分を閉じ込めることを重視したい。上記例では販売・配送ごとに独自の商品モデルを定義し、各々に必要な情報だけを認知できる形にする形である。</p>\n<h1 id=\"go-における-ddd-の実現\">Go における DDD の実現</h1>\n<p>最初に結論を紹介すると、Go では以下のような形が良いのではないかと現時点では考えている。まずは説明前に実際のストラクチャを見て欲しい。</p>\n<p>当然ながらここで例示するものが正解というわけではないし、機能の追加や時間の経過によって有用な形は代わり得る。</p>\n<h2 id=\"提案アーキテクチャ\">提案アーキテクチャ</h2>\n<pre><code class=\"hljs language-go\">.\n├── boundedcontextA\n│   └── usecase <span class=\"hljs-comment\">// define application usecase</span>\n│       ├── subdomainA\n│           └── a_usecase.<span class=\"hljs-keyword\">go</span>\n│           └── b_usecase.<span class=\"hljs-keyword\">go</span>\n│       ├── subdomainB\n│           └── c_usecase.<span class=\"hljs-keyword\">go</span>\n│   └── domain <span class=\"hljs-comment\">// define domain model</span>\n│       └── subdomainA\n│           └── model.<span class=\"hljs-keyword\">go</span> \n│           └── repository.<span class=\"hljs-keyword\">go</span> <span class=\"hljs-comment\">// only interface</span>\n│           └── service.<span class=\"hljs-keyword\">go</span>\n│       └── subdomainB\n│           └── model.<span class=\"hljs-keyword\">go</span> \n│           └── repository.<span class=\"hljs-keyword\">go</span>\n│           └── service.<span class=\"hljs-keyword\">go</span>\n│   └── presentation <span class=\"hljs-comment\">// API endpoint</span>\n│       └── a_handler.<span class=\"hljs-keyword\">go</span>\n│       └── b_handler.<span class=\"hljs-keyword\">go</span>\n│       └── resolver\n│           └── resolver.<span class=\"hljs-keyword\">go</span>\n│   └── infrastructure <span class=\"hljs-comment\">// impliment repository</span>\n│       └── datastore\n│       └── externalservice\n│   └── pkg <span class=\"hljs-comment\">// general lib for the boundary</span>\n│       └── apiclient\n│       └── shareditem\n│       └── trace\n│   └── <span class=\"hljs-keyword\">go</span>.mod\n├── boundedcontextB\n│   └── usecase\n│       └── ...\n│   └── domain\n│       └── ...\n│   └── presentation\n│       └── ...\n│   └── infrastructure\n│       └── ...\n│   └── pkg\n│       └── ...\n│   └── <span class=\"hljs-keyword\">go</span>.mod\n├── boundedcontextC\n│   └── ...\n├── server\n│   └── middleware <span class=\"hljs-comment\">// common</span>\n│   └── main.<span class=\"hljs-keyword\">go</span>\n├── <span class=\"hljs-keyword\">go</span>.mod\n</code></pre>\n<p>基本的な考え方は以下である。</p>\n<p>方針</p>\n<ul>\n<li>複数の境界やドメインを同じサービスで提供し得る構成で考える</li>\n<li>struct や interface のを使う側における見え方を意識する</li>\n<li>トップレベル以下にコンテキストの境界毎にディレクトリを作る\n<ul>\n<li>小ディレクトリに近いストラクチャを持つモジュラモノリスのような構造</li>\n<li>サービスとしてモノリスで提供する前提だが、必要に応じてマイクロサービスとしてデプロイしたり、リポジトリの分離の容易さを意識</li>\n</ul>\n</li>\n</ul>\n<p>補足</p>\n<ul>\n<li>ファイル自体はわかりやすさのために定義しているが、別ファイルを設けることは必須ではなく、また同様の概念(e.g. model)を複数ファイルに分けることもある</li>\n<li>必要に応じて親・子ディレクトリを追加で設けて柔軟に変更する</li>\n<li>boundary は<code>sales</code>や<code>delivery</code>のようなビジネスドメイン的な概念もあれば<code>authentication</code>などのシステム上必要な概念もありえる</li>\n<li>boundary 毎のモジュール化は必須ではない</li>\n</ul>\n<p>提案モデルを深掘りする前に、レイヤードアーキテクチャを忠実に再現した場合にどうなるのかを例示し、追って違いを交えつつ説明する。</p>\n<p>素直なレイヤードアーキテクチャを Go で表現すると以下のようになる。</p>\n<pre><code class=\"hljs language-go\">.\n├── usecase\n│   └── a_usecase.<span class=\"hljs-keyword\">go</span>\n│   └── b_usecase.<span class=\"hljs-keyword\">go</span>\n├── domain\n│   ├── model\n│   ├── repository\n│   │   └── a_repository.<span class=\"hljs-keyword\">go</span> <span class=\"hljs-comment\">// interface</span>\n│   └── service\n├── infrastructure\n│   └── persistence\n│       └── database\n│           └── a_repository.<span class=\"hljs-keyword\">go</span> <span class=\"hljs-comment\">// impl</span>\n├── presentation\n│   └── api\n│       └── server\n│           ├── auth\n│           ├── handler\n│           │   ├── a_handler.<span class=\"hljs-keyword\">go</span>\n│           │   ├── b_handler.<span class=\"hljs-keyword\">go</span>\n│           │   └── yyy_handler.<span class=\"hljs-keyword\">go</span>\n│           ├── middleware\n│           └── router\n└── <span class=\"hljs-keyword\">go</span>.mod\n</code></pre>\n<p>以下で提案アーキテクチャのポイントを説明する。</p>\n<h2 id=\"ポイント\">ポイント</h2>\n<h3 id=\"各レイヤー単位でドメインを考慮したパッケージを作る\">各レイヤー単位でドメインを考慮したパッケージを作る</h3>\n<p>提案の例ではレイヤー毎にフラットなディレクトリを作らないこと、またレイヤー毎に近しい要素は同じパッケージ以下に置く事を意識している。\n具体的には、model.go や repository.go を (サブ)ドメイン (以下サブドメインも全てドメインと便宜上表現する) 直下に配置している。\nこうすることで <code>{domain_name}.{element_name}</code> という見え方を表現できる。<br>\nsale というドメイン以下で item の出品と考えると以下のように表現でき、private なフィールドの公開範囲も制限が可能である</p>\n<ul>\n<li>domain/sale/\n<ul>\n<li>sale.Item</li>\n<li>sale.Repository</li>\n</ul>\n</li>\n<li>usecase/sale/\n<ul>\n<li>sale.PublishUsecase</li>\n<li>sale.DropUsecase</li>\n</ul>\n</li>\n</ul>\n<p>他の言語ではパッケージの利用時の見え方は意識しなくても良いものもあるのだが、Go の場合は「パッケージ + 要素名」を利用時に参照することに加え、「パッケージ名は要素の名前に含めない」というプラクティス(✗ item.ItemRepository → ◯ item.Repository) もあるため、必然的に利用時のためのパッケージと要素の配置位置を意識する必要がある。</p>\n<p>レイヤードアーキテクチャを素直に表現した場合、usecase や repository ディレクトリ以下に全てのリポジトリのインターフェースが以下のように並べられる。</p>\n<pre><code class=\"hljs language-go\">.\n├── usecase\n│   └── delivery_usecase.<span class=\"hljs-keyword\">go</span>\n│   └── sale_usecase.<span class=\"hljs-keyword\">go</span>\n├── domain\n│   ├── model\n│      └── delivery.<span class=\"hljs-keyword\">go</span>\n│      └── item.<span class=\"hljs-keyword\">go</span>\n│      └── sale.<span class=\"hljs-keyword\">go</span>\n│   ├── repository\n│      └── delivery.<span class=\"hljs-keyword\">go</span>\n│      └── item.<span class=\"hljs-keyword\">go</span>\n│      └── sale.<span class=\"hljs-keyword\">go</span>\n</code></pre>\n<p>この場合以下のような点で扱いづらさがある。</p>\n<ul>\n<li>レイヤーのディレクトリ以下に平坦にファイルを並べると特定のドメインのみに必要なプライベートな要素が他のドメインにも見える</li>\n<li>リソースを配置するディレクトリがより分散しやすくなる\n<ul>\n<li>凝縮度の低下</li>\n</ul>\n</li>\n<li>名付けで 「何であるのか(e.g. repository)」が要素でなく package の方に寄せられる\n<ul>\n<li>repository.Delivery、repository.Item &#x3C;> delivery.Repository、item.Repository</li>\n</ul>\n</li>\n</ul>\n<p>当然以下のようにレイヤー毎にサブディレクトリを設けることも考えられるが、特にドメイン周りで近しい要素間の循環参照が起きやすく、 import の複雑性を考えたくないため、model, repository (interface), service などは同一階層上で置いてしまった方が扱い易いと考える。</p>\n<pre><code class=\"hljs language-go\">.\n├── usecase\n│   └── delivery\n│      └── usecase.<span class=\"hljs-keyword\">go</span>\n│   └── sale\n│      └── usecase.<span class=\"hljs-keyword\">go</span>\n├── domain\n│   ├── model\n│      └── delivery\n│          └── delivery.<span class=\"hljs-keyword\">go</span>\n│      └── item\n│          └── item.<span class=\"hljs-keyword\">go</span>\n│      └── sale\n│          └── sale.<span class=\"hljs-keyword\">go</span>\n│   ├── repository\n│      └── delivery\n│          └── delivery.<span class=\"hljs-keyword\">go</span>\n│      └── item\n│          └── item.<span class=\"hljs-keyword\">go</span>\n│      └── sale\n│          └── sale.<span class=\"hljs-keyword\">go</span>\n│   ├── service\n│      └── delivery\n...\n</code></pre>\n<h3 id=\"bounded-context-によるモジュールの分離\">Bounded context によるモジュールの分離</h3>\n<p>提案では「境界づけられたコンテキスト」毎にトップディレクトリに配置し、それぞれをモジュール化し、各モジュールを server/main.go から参照する形を想定していた。</p>\n<p>この形の利点としては以下である。</p>\n<ul>\n<li>境界の異なるものは干渉しない</li>\n<li>リリース時に境界毎の変更を意識せずリリースタイミングを調整しやすい\n<ul>\n<li>モジュール化していないとモノレポの場合、master (GitFlow なら develop)ブランチにマージすることは本番化を意味する(Feature Toggleなどを使っていない場合)が、モジュール化すると main.go の go.mod に含めない限り利用されない</li>\n</ul>\n</li>\n<li>チームやプロダクトの成長に伴うサービスの分割がしやすい\n<ul>\n<li>境界毎にサービスとして完結した形にすることで main.go を追加するだけで別サービスとしてデプロイできる\n<ul>\n<li>サービス規模が大きくなったなどでアクセスの分離がしやすい</li>\n</ul>\n</li>\n<li>メンバー増加に伴い専用のチームを作りリポジトリを分離する場合でも対応が簡単\n<ul>\n<li>レイヤー毎に分離されて配置されているとリポジトリ分離のためには複数箇所から関連リソースをかき集める必要がある</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>この方法には同時にいくつかの欠点も存在する</p>\n<ul>\n<li>モジュールとして分離すると、全体で利用したいライブラリ (共有カーネル等) をモジュール化してインポートする必要がある\n<ul>\n<li>モジュール化していない場合は変更をそのまま参照できる</li>\n</ul>\n</li>\n<li>サービスとしてのテストの手間\n<ul>\n<li>go.work によりローカルで別モジュールの開発は簡単になったが、go.work は git 管理しない前提のため、実環境へデプロイするためには main.go の go.mod が tag でなくブランチを参照する必要がある。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"おわりに\">おわりに</h1>\n<p>本記事では Go で DDD ベースの実装を行う場合のパッケージストラクチャの案を紹介した。</p>\n<p>アプローチはチームの大きさやスキル間、サービスの特性によって変えるべきであり、例えばコンテキストを大きく捉えてサブドメインの構成要素を多くモデリングすることで細かくモジュールを分けないといった考え方もあるだろう。</p>\n<p>また、今回のストラクチャを深掘りするとコンテキスト内でも <code>saleitem</code> (売るための商品) と <code>solditem</code> (売れた商品) のドメインを設け、それぞれ別のフィールドを持たせる方が扱いやすい場合もある。</p>\n<p>一概に正解はないが、ポイントとしては Go では <code>{domain_name}.{element_name}</code> という利用者からの見え方を意識し、結合度を下げつつ凝縮度を高める設計をすると良いと考えている。</p>","title":"Go DDD Package Structure Pattern","date":"2023-08-01","tags":["engineering","go","ddd"],"description":"Go で DDD を表現するのは単純にレイヤードにするのではなく、ドメイン毎にパッケージの見え方を意識して構成をしたほうが良いという考察。","published":true,"company":true}},"__N_SSG":true}